---
description: –ü—Ä–∞–≤–∏–ª–∞ —Ä–∞–±–æ—Ç—ã —Å API –∫—Ä–∏–ø—Ç–æ–±–∏—Ä–∂ MEXC –∏ Gate.io
globs: ["src/infrastructure/**/*.py", "src/application/services/**/*.py"]
---

# –ü—Ä–∞–≤–∏–ª–∞ —Ä–∞–±–æ—Ç—ã —Å API –∫—Ä–∏–ø—Ç–æ–±–∏—Ä–∂

## MEXC API –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è

### Endpoints –∏ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
```python
class Config:
    # –û—Å–Ω–æ–≤–Ω—ã–µ endpoints
    mexc_futures_public: str = "https://contract.mexc.com/api/v1"
    mexc_futures_web: str = "https://www.mexc.com/api/platform/futures/api/v1"
    mexc_spot: str = "https://api.mexc.com"

    # WebSocket
    mexc_ws_url: str = "wss://contract.mexc.com/edge"

    # API URLs
    @property
    def contract_detail_url(self) -> str:
        return f"{self.mexc_futures_public}/contract/detail"

    @property
    def futures_ticker_url(self) -> str:
        return f"{self.mexc_futures_public}/contract/ticker"

    @property
    def spot_24h_url(self) -> str:
        return f"{self.mexc_spot}/api/v3/ticker/24hr"

    @property
    def wallet_networks_url(self) -> str:
        return f"{self.mexc_spot}/api/v3/capital/config/getall"
```

### MexcClient —Å—Ç—Ä—É–∫—Ç—É—Ä–∞
```python
class MexcClient:
    def __init__(self, config: Config, http_client: HttpClient, time_sync: MexcTimeSync):
        self.config = config
        self.http_client = http_client
        self.time_sync = time_sync

    async def fetch_contract_detail(self, symbol: str) -> Tuple[bool, str, Optional[ContractDetailData]]:
        """–ü–æ–ª—É—á–∏—Ç—å –¥–µ—Ç–∞–ª–∏ –∫–æ–Ω—Ç—Ä–∞–∫—Ç–∞."""
        url = self.config.contract_detail_url
        params = {"symbol": symbol}

        ok, error, data = await self.http_client.get_json(url, params)
        if not ok:
            return False, error, None

        # –ü–∞—Ä—Å–∏–Ω–≥ –æ—Ç–≤–µ—Ç–∞
        if isinstance(data, dict) and data.get("success"):
            contract_data = ContractDetailData.from_dict(data["data"])
            return True, "", contract_data

        return False, "Invalid response format", None

    async def fetch_futures_ticker(self, symbol: str) -> Tuple[bool, str, Optional[FuturesTickerData]]:
        """–ü–æ–ª—É—á–∏—Ç—å —Ñ—å—é—á–µ—Ä—Å–Ω—ã–π —Ç–∏–∫–µ—Ä."""
        url = self.config.futures_ticker_url
        params = {"symbol": symbol}

        ok, error, data = await self.http_client.get_json(url, params)
        if not ok:
            return False, error, None

        if isinstance(data, dict) and data.get("success"):
            ticker_data = FuturesTickerData.from_dict(data["data"])
            return True, "", ticker_data

        return False, "Invalid ticker response", None
```

## Gate.io API –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è

### GateClient —Å—Ç—Ä—É–∫—Ç—É—Ä–∞
```python
class GateClient:
    def __init__(self, config: Config, http_client: HttpClient):
        self.config = config
        self.http_client = http_client

    async def fetch_futures_contracts(self) -> Tuple[bool, str, List[GateFuturesContractData]]:
        """–ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ —Ñ—å—é—á–µ—Ä—Å–Ω—ã—Ö –∫–æ–Ω—Ç—Ä–∞–∫—Ç–æ–≤."""
        url = f"{self.config.gate_base_url}/futures/usdt/contracts"

        ok, error, data = await self.http_client.get_json(url)
        if not ok:
            return False, error, []

        if isinstance(data, list):
            contracts = [GateFuturesContractData.from_dict(item) for item in data]
            return True, "", contracts

        return False, "Invalid contracts response", []

    async def fetch_futures_tickers(self) -> Tuple[bool, str, List[GateFuturesTickerData]]:
        """–ü–æ–ª—É—á–∏—Ç—å —Ñ—å—é—á–µ—Ä—Å–Ω—ã–µ —Ç–∏–∫–µ—Ä—ã."""
        url = f"{self.config.gate_base_url}/futures/usdt/tickers"

        ok, error, data = await self.http_client.get_json(url)
        if not ok:
            return False, error, []

        if isinstance(data, list):
            tickers = [GateFuturesTickerData.from_dict(item) for item in data]
            return True, "", tickers

        return False, "Invalid tickers response", []
```

## WebSocket –∫–ª–∏–µ–Ω—Ç—ã

### MexcWebSocketClient
```python
class MexcWebSocketClient:
    def __init__(self, config: Config):
        self.config = config
        self.websocket = None
        self.reconnect_delay = 1

    async def connect(self) -> None:
        """–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ —Å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–º –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ–º."""
        while True:
            try:
                self.websocket = await websockets.connect(self.config.mexc_ws_url)
                logger.info("Connected to MEXC WebSocket")
                break
            except Exception as e:
                logger.error(f"WebSocket connection failed: {e}")
                await asyncio.sleep(self.reconnect_delay)
                self.reconnect_delay = min(self.reconnect_delay * 2, 60)

    async def listen(self):
        """–°–ª—É—à–∞—Ç—å —Å–æ–æ–±—â–µ–Ω–∏—è —Å –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ–º."""
        while True:
            try:
                if not self.websocket:
                    await self.connect()

                # –ü–æ–¥–ø–∏—Å–∫–∞ –Ω–∞ –∫–∞–Ω–∞–ª
                subscribe_msg = {
                    "method": "SUBSCRIBE",
                    "params": ["contract@ticker:all"],
                    "id": 1
                }
                await self.websocket.send(json.dumps(subscribe_msg))

                async for message in self.websocket:
                    yield json.loads(message)

            except websockets.exceptions.ConnectionClosed:
                logger.warning("WebSocket connection closed, reconnecting...")
                await self.connect()
            except Exception as e:
                logger.error(f"WebSocket error: {e}")
                await asyncio.sleep(5)
```

## –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö

### –¶–µ–Ω–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ
```python
def _fmt_money(value: float) -> str:
    """–§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–µ–Ω–µ–∂–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π."""
    if isinstance(value, str):
        value = float(value)

    if abs(value) >= 1:
        return f"{value:,.2f}"  # 1,234.56
    else:
        return f"{value:.6f}"   # 0.000123

def _fmt_volume(value: float) -> str:
    """–§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –æ–±—ä–µ–º–æ–≤."""
    if isinstance(value, str):
        value = float(value)

    if value >= 1_000_000:
        return f"{value/1_000_000:.1f}M"  # 1.2M
    elif value >= 1_000:
        return f"{value/1_000:.1f}K"      # 1.2K
    else:
        return f"{value:.0f}"             # 123
```

### –°–ø—Ä–µ–¥ –∏ –ø—Ä–æ—Ü–µ–Ω—Ç—ã
```python
def calculate_spread(last_price: float, fair_price: float) -> Tuple[str, str]:
    """–†–∞—Å—á–µ—Ç —Å–ø—Ä–µ–¥–∞ –º–µ–∂–¥—É —Ü–µ–Ω–∞–º–∏."""
    if fair_price == 0:
        return "0.00%", "üü¢"

    spread_percent = ((last_price - fair_price) / fair_price) * 100

    # –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Å —Ü–≤–µ—Ç–æ–º
    if spread_percent > 5:
        color = "üî¥"  # SHORT (—Ü–µ–Ω–∞ –≤—ã—à–µ —Å–ø—Ä–∞–≤–µ–¥–ª–∏–≤–æ–π)
    elif spread_percent < -5:
        color = "üü¢"  # LONG (—Ü–µ–Ω–∞ –Ω–∏–∂–µ —Å–ø—Ä–∞–≤–µ–¥–ª–∏–≤–æ–π)
    else:
        color = "üü°"  # NEUTRAL

    return f"{spread_percent:+.2f}%", color
```

## –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–∏–º–≤–æ–ª–æ–≤

### –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è —Å–∏–º–≤–æ–ª–æ–≤
```python
def _normalize_mexc_symbol(self, symbol: str) -> str:
    """–ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è —Å–∏–º–≤–æ–ª–∞ –¥–ª—è MEXC."""
    symbol = symbol.strip().replace("-", "_").replace("/", "_").upper()
    if "_" not in symbol:
        symbol = f"{symbol}_USDT"
    return symbol

def _normalize_gate_symbol(self, symbol: str) -> str:
    """–ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è —Å–∏–º–≤–æ–ª–∞ –¥–ª—è Gate.io."""
    symbol = symbol.upper()
    if "_" not in symbol:
        symbol = f"{symbol}_USDT"
    return symbol
```

## Time synchronization

### MexcTimeSync
```python
class MexcTimeSync:
    def __init__(self):
        self.server_time_offset = 0

    async def sync(self, http_client: HttpClient, time_url: str) -> None:
        """–°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –≤—Ä–µ–º–µ–Ω–∏ —Å —Å–µ—Ä–≤–µ—Ä–æ–º."""
        try:
            ok, error, data = await http_client.get_json(time_url)
            if ok and isinstance(data, dict):
                server_time = data.get("serverTime", 0)
                local_time = int(time.time() * 1000)
                self.server_time_offset = server_time - local_time
                logger.info(f"Time synced, offset: {self.server_time_offset}ms")
        except Exception as e:
            logger.error(f"Time sync failed: {e}")

    def get_server_time(self) -> int:
        """–ü–æ–ª—É—á–∏—Ç—å —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –≤—Ä–µ–º—è —Å–µ—Ä–≤–µ—Ä–∞."""
        return int(time.time() * 1000) + self.server_time_offset
```

## API –∫–ª—é—á–∏ –∏ –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è

### –ü–æ–¥–ø–∏—Å—å –∑–∞–ø—Ä–æ—Å–æ–≤
```python
def _sign_request(self, params: Dict[str, Any]) -> str:
    """–ü–æ–¥–ø–∏—Å—å –∑–∞–ø—Ä–æ—Å–∞ –¥–ª—è MEXC API."""
    query_string = "&".join([f"{k}={v}" for k, v in sorted(params.items())])
    signature = hmac.new(
        self.config.mexc_api_secret.encode('utf-8'),
        query_string.encode('utf-8'),
        hashlib.sha256
    ).hexdigest()
    return signature

async def _make_authenticated_request(self, endpoint: str, params: Dict[str, Any]) -> Tuple[bool, str, Any]:
    """–ê—É—Ç–µ–Ω—Ç–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∑–∞–ø—Ä–æ—Å."""
    params["timestamp"] = self.time_sync.get_server_time()
    params["signature"] = self._sign_request(params)

    headers = {
        "X-MEXC-APIKEY": self.config.mexc_api_key,
        "Content-Type": "application/json"
    }

    return await self.http_client.get_json(endpoint, params, headers)
```