---
description: Правила написания Python кода для MEXC Telegram Bot
globs: ["**/*.py"]
---

# Правила написания Python кода

## Импорты
```python
# Правильно
import asyncio
from typing import Dict, Optional, List
from dataclasses import dataclass

from core.config import Config
from infrastructure.http_client import HttpClient
from application.services.mexc_info_service import MexcInfoService

# Неправильно - группировка нарушена
from core.config import Config
import asyncio
from application.services.mexc_info_service import MexcInfoService
from typing import Dict, Optional
```

## Типизация
```python
# Правильно
def process_data(data: Dict[str, Any]) -> Optional[str]:
    pass

class MexcClient:
    def __init__(self, config: Config, http_client: HttpClient) -> None:
        self.config = config
        self.http_client = http_client

# Неправильно - нет типизации
def process_data(data):
    pass
```

## Классы и методы
```python
# Правильно - dependency injection
class MexcInfoService:
    def __init__(self, mexc_client: MexcClient, markdown_service: MarkdownService) -> None:
        self.mexc_client = mexc_client
        self.markdown_service = markdown_service

    async def get_info(self, symbol: str) -> str:
        # бизнес-логика здесь
        pass

# Неправильно - singleton или global state
class MexcInfoService:
    _instance = None

    @classmethod
    def get_instance(cls):
        if cls._instance is None:
            cls._instance = cls()
        return cls._instance
```

## Async/await
```python
# Правильно - async везде где нужно
async def get_mexc_data(self, symbol: str) -> Tuple[Optional[ExchangeData], List[str]]:
    tasks = [
        self.mexc_client.fetch_contract_detail(symbol),
        self.mexc_client.fetch_futures_ticker(symbol),
    ]
    results = await asyncio.gather(*tasks, return_exceptions=True)
    return self._process_results(results)

# Неправильно - блокирующие вызовы в async функциях
async def get_data(self, symbol: str):
    # Это заблокирует event loop!
    response = requests.get(url)  # blocking call
    return response.json()
```

## Обработка ошибок
```python
# Правильно - конкретные исключения
try:
    result = await self.http_client.get_json(url, params)
    return result
except aiohttp.ClientError as e:
    logger.error(f"HTTP error for {url}: {e}")
    return None, [f"HTTP error: {str(e)}"]

# Неправильно - голый except
try:
    result = await self.http_client.get_json(url, params)
    return result
except:
    return None, ["Unknown error"]
```

## Логирование
```python
# Правильно - использование logger
import logging
logger = logging.getLogger(__name__)

logger.debug(f"Starting API requests for symbol: {symbol}")
logger.info("Fair price alert services started")
logger.error(f"Failed to parse response: {e}")

# Неправильно - print statements
print(f"Processing {symbol}")
print("Error:", e)
```

## Конфигурация
```python
# Правильно - через dataclass
@dataclass(frozen=True)
class Config:
    bot_token: str
    mexc_api_key: Optional[str] = None
    alert_chat_id: str = "-1003321617744"

    @classmethod
    def load(cls) -> "Config":
        load_dotenv()
        bot_token = os.getenv("BOT_TOKEN", "").strip()
        if not bot_token:
            raise ValueError("BOT_TOKEN environment variable is required")
        return cls(bot_token=bot_token)

# Неправильно - прямой доступ к os.getenv в коде
def get_config():
    bot_token = os.getenv("BOT_TOKEN")
    if not bot_token:
        raise ValueError("BOT_TOKEN required")
    return {"bot_token": bot_token}
```

## Форматирование цен и чисел
```python
# Правильно - использование утилит
def _fmt_money(value: float) -> str:
    """Format money value for display."""
    if abs(value) >= 1:
        return f"{value:,.2f}"
    else:
        return f"{value:.6f}"

# Неправильно - inline форматирование
price_str = ".2f"
volume_str = ",.0f"
```